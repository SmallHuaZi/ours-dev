#ifndef USTL_FMT_DETAILS_BUFFER_OUTPUT_H
#define USTL_FMT_DETAILS_BUFFER_OUTPUT_H

#include <ustl/util/move.hpp>

#include <ustl/iterator/traits.hpp>
#include <ustl/iterator/distance_of.hpp>
#include <ustl/iterator/back_insert_iterator.hpp>

#include <ustl/algorithms/copy.hpp>
#include <ustl/algorithms/minmax.hpp>
#include <ustl/algorithms/transform.hpp>
#include <ustl/algorithms/generation.hpp>

#include <ustl/mem/address_of.hpp>
#include <ustl/mem/uninitialized.hpp>

#include <ustl/traits/is_same.hpp>
#include <ustl/traits/conditional.hpp>

#include <ustl/views/string_view.hpp>

namespace ustl::fmt::details {

    template <typename CharType>
    struct OutputBuffer
    {
        typedef CharType            Element;
        typedef Element *           PtrMut;
        typedef Element const *     Ptr;
        typedef Element &           RefMut;
        typedef Element const &     Ref;

        template <class T>
        explicit OutputBuffer(PtrMut ptr, usize capacity, T* obj)
            : ptr_(ptr),
              capacity_(capacity),
              flush_([](Element* p, usize n, void* o) { static_cast<T*>(o)->flush(p, n); }),
              obj_(obj)
        {}

        auto reset(Element* ptr, usize capacity) -> void
        {
            ptr_ = ptr;
            capacity_ = capacity;
        }

        auto make_output_iterator()
        { return iter::BackInsertIterator(*this); }

        // Used in std::back_insert_iterator.
        auto push_back(Element c) -> void
        {
            ptr_[size_++] = c;

            // Profiling showed flushing after adding is more efficient than flushing
            // when entering the function.
            if (size_ == capacity_) {
                flush();
            }
        }

        /// Copies the input str to the buffer.
        ///
        /// Since some of the input is generated by std::to_chars, there needs to be a
        /// conversion when Char is wchar_t.
        template <typename  InCharT>
        void copy(views::BasicStringView<InCharT> str)
        {
            // When the underlying iterator is a simple iterator the capacity_ is
            // infinite. For a string or container back_inserter it isn't. This means
            // that adding a large string to the buffer can cause some overhead. In that
            // case a better approach could be:
            // - flush the buffer
            // - container.append(str.begin(), str.end());
            // The same holds true for the fill.
            // For transform it might be slightly harder, however the use case for
            // transform is slightly less common; it converts hexadecimal values to
            // upper case. For integral these strings are short.
            // TODO FMT Look at the improvements above.
            usize n = str.size();

            flush_on_overflow(n);
            if (n < capacity_) { //  push_back requires the buffer to have room for at least one character (so use <).
                algorithms::copy_n(str.data(), n, mem::address_of(ptr_[size_]));
                size_ += n;
                return;
            }

            // The output doesn't fit in the internal buffer.
            // Copy the data in "capacity_" sized chunks.
            // _LIBCPP_ASSERT_INTERNAL(size_ == 0, "the buffer should be flushed by flush_on_overflow");
            const InCharT* first = str.data();
            do {
                usize chunk = algorithms::min(n, capacity_);
                algorithms::copy_n(first, chunk, mem::address_of(ptr_[size_]));
                size_ = chunk;
                first += chunk;
                n -= chunk;
                flush();
            } while (n);
        }

        /// A ustl::transform wrapper.
        ///
        /// Like @ref copy it may need to do type conversion.
        template <typename Iterator, typename UnaryPredicate,
                  typename InCharT = typename iter::IterTraits<Iterator>::Element>
        auto transform(Iterator first, Iterator last, UnaryPredicate pred) -> void
        {
            // _LIBCPP_ASSERT_INTERNAL(first <= last, "not a valid range");
            usize n = static_cast<usize>(last - first);
            flush_on_overflow(n);
            if (n < capacity_) { //  push_back requires the buffer to have room for at least one character (so use <).
                algorithms::transform(first, last, mem::address_of(ptr_[size_]), ustl::move(pred));
                size_ += n;
                return;
            }

            // The output doesn't fit in the internal buffer.
            // Transform the data in "capacity_" sized chunks.
            // _LIBCPP_ASSERT_INTERNAL(size_ == 0, "the buffer should be flushed by flush_on_overflow");
            do {
                usize chunk = std::min(n, capacity_);
                algorithms::transform(first, first + chunk, std::addressof(ptr_[size_]), pred);
                size_ = chunk;
                first += chunk;
                n -= chunk;
                flush();
            } while(n);
        }

        /// A \c fill_n wrapper.
        auto fill(usize n, Element value) -> void
        {
            flush_on_overflow(n);
            if (n < capacity_) { //  push_back requires the buffer to have room for at least one character (so use <).
                algorithms::fill_n(mem::address_of(ptr_[size_]), n, value);
                size_ += n;
                return;
            }

            // The output doesn't fit in the internal buffer.
            // Fill the buffer in "capacity_" sized chunks.
            // _LIBCPP_ASSERT_INTERNAL(size_ == 0, "the buffer should be flushed by flush_on_overflow");
            do {
                usize chunk = algorithms::min(n, capacity_);
                algorithms::fill_n(mem::address_of(ptr_[size_]), chunk, value);
                size_ = chunk;
                n -= chunk;
                flush();
            } while(n);
        }

        auto flush() -> void
        {
            flush_(ptr_, size_, obj_);
            size_ = 0;
        }

        /// Flushes the buffer when the output pred would overflow the buffer.
        ///
        /// A simple approach for the overflow detection would be something along the
        /// lines:
        /// \code
        /// // The internal buffer is large enough.
        /// if (n <= capacity_) {
        ///   // Flush when we really would overflow.
        ///   if (size_ + n >= capacity_)
        ///     flush();
        ///   ...
        /// }
        /// \endcode
        ///
        /// This approach works for all cases but one:
        /// A FormatToBufferBase where \ref enable_direct_output is true.
        /// In that case the \ref capacity_ of the buffer changes during the first
        /// \ref flush. During that pred the output buffer switches from its
        /// writer_ to its storage_. The \ref capacity_ of the former depends
        /// on the value of n, of the latter is a fixed size. For example:
        /// - a format_to_n call with a 10'000 char buffer,
        /// - the buffer is filled with 9'500 chars,
        /// - adding 1'000 elements would overflow the buffer so the buffer gets
        ///   changed and the \ref capacity_ decreases from 10'000 to
        ///   buffer_size (256 at the time of writing).
        ///
        /// This means that the \ref flush for this class may need to copy a part of
        /// the internal buffer to the proper output. In this example there will be
        /// 500 characters that need this copy pred.
        ///
        /// Note it would be more efficient to write 500 chars directly and then swap
        /// the buffers. This would make the code more complex and \ref format_to_n is
        /// not the most common use case. Therefore the optimization isn't done.
        void flush_on_overflow(usize n) {
            if (size_ + n >= capacity_) {
                flush();
            }
        }

    private:
        PtrMut ptr_;
        usize size_;
        usize capacity_;
        void* obj_;
        auto (*flush_)(PtrMut, usize, void *) -> void;
    };

} // namespace ustl::fmt::details

#endif // #ifndef USTL_FMT_DETAILS_BUFFER_H