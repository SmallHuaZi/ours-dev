# <center> 第二章 Ours-OS 的设计与实现
&emsp;&emsp;本章中我们将详细介绍 ours 的设计思路与分层架构。<br/>
&emsp;&emsp;首先我们在 2.1 中引入 ours 概念设计，明确功能需求以及架构设计。接着将在 2.2 中看到如何维护架构相关代码与架构无关代码之间通信的接口协议，了解到如何在新增部分特定架构代码后就能得到支持该架构的内核的巧妙思路。最后在2.3和2.4中分别可以看到本工作预期实现的内核组件的高层次设计和系统实施方案。
## 2.1 概念设计
### 2.1.1 系统目标与需求
ours的目标是构建一个具有基本内核组件的微内核操作系统，故本系统需求主要聚焦于内存管理和任务调度，辅以部分非核心的功能组件。具体需求如下：

**内存管理**：实现基本的内存分配和回收机制，确保操作系统能够管理有限的物理内存资源。具体需求如下：
* 物理内存模型抽象：由于不同计算机可能对地址总线的使用存在差异或是出于地址隔离、IO保留等目的，可能会导致物理地址空间存在不连续的情况，从而本该连续的物理地址空间出现洞。而ours的PMM(Physical memory manager)按页帧管理系统，在系统初始化时就预分配所有页帧描述符，在这种情况下，如果按可用地址空间的长度来计算，就会消耗大量内存空间到去描述一些无意义的区域。例如早期的一些X86系统将地址0xA0000到0xBFFFF这2MB内存用作VGA buffer，若为其分配64字节的页帧描述符，就要耗费32KB的内存。对此我们难以容忍，所以对于物理模型的抽象成了重中之重。还好站在前人的肩膀上总是会让问题变得简单些，通过查阅和对比 Linux 与 Zircon 两个内核对此的解决方案，最终 ours 敲定使用Linux的“稀疏内存模型”作为解决方案。

* 基本的NUMA架构支持：NUMA即非一致内存访问，其核心是整个物理地址空间被划分为不同的域，不同CPU对不同域的亲和度有所不同，即访问不同域的地址空间所占用时间跨度有所差异。目前，虽然NUMA架构主要活动在服务器上，但考虑到该功能与后续的资源空间管理有所契合，则可以实现对其的基本支持。

* 写时复制内存：为了避免无意义的拷贝，例如父进程创造子进程

* 共享地址空间：作为IPC机制核心之一的基础，这是被要求实现的，以便进程间可以通过读写内存而非仅仅是中断进行通信，可以降低不必要的性能开销。

* 页帧分配器：按页帧管理物理内存，提供分配与释放接口，并统计相关数据，以便降低碎片化及数据分析。它是内存资源管理的核心。

* 对象分配器：对象池是内存管理的常见实现，在ours中是为了使用频繁的对象，保证其分配与释放的速度，避免过多的持有PMM的锁，而导致太多的竞争和等待。

**任务调度**： 实现合理的任务调度算法，确保操作系统能够有效管理并发进程。具体需求如下：
* 任务模型抽象：在ours中，由于不同级别的任务需要，我们将任务分为作业、进程、线程三个层次，具体定义如下：<br/>&emsp;&emsp; 作业（Job）：作业是一个高级的调度单位，通常代表一个需要完成的任务，它包含一个或多个进程。作业的生命周期通常由用户或系统启动，并由调度器决定何时执行。作业在系统中可能会经历多个阶段，如等待、运行和完成。
<br/>&emsp;&emsp; 进程（Process）：进程是 ours 中资源分配的基本单位，它真正意义上持有自己的内存空间以及其它的内核句柄。进程可能会处于多个状态，如就绪、运行、阻塞、终止等。调度器根据进程的状态决定是否将其调度到 CPU 执行。
<br/>&emsp;&emsp; 线程（Thread）：线程是进程中的最小调度单位，仅持有其所属进程资源的弱引用，但具有独立的执行栈和寄存器。

* 调度策略的设计与实现：EEVDF是ours的首选调度算法，其基于近乎完全公平的调度策略。

* 作业、进程、线程的生命周期管理。

**并发支持**： 具体需求如下：
* 并发原语支持。
* 锁和同步支持。
* CPU本地存储支持。

### 2.1.2 系统架构设计
&emsp;&emsp; 系统整体架构如下图所示，其中K:前缀表示内核空间，U:前缀则表示用户空间。Phys是最底层的模块，同时它的生命周期也最短，它主要用于收集物理平台的基本信息，将Main加载到内存空间，并传递给Main它收集到的信息，在Main初始化完成后被Main卸载出系统。它的两个模块Legacy Boot和Core 分别是对一些传统Bootloader的兼容性支持和与对Main引导镜像解析的核心代码。Main是包含少许可回收初始化代码的可执行文件，它是整个内核构造的核心，是内核服务的提供者。其中内存管理模块包含PMM(Physical memory manager)和VMM(Virtual memory manager)，两者分别提供了运行时物理内存管理与虚拟内存管理；而任务管理模块分为Task和Sched，分别提供任务资源管理和任务调度功能。往上则是内核提供用户层可访问的接口层，不同于传统的Linux系统调用，我们采用KVDSO来使现，避免传参问题以及提供用户直接访问系统接口的能力。
<br/>
![2.1系统架构设计图](./Screenshot%20from%202025-02-26%2005-26-23.png) <br/>
**<center>图1-ours系统架构设计图</center>**

## 2.2 接口协议
&emsp;&emsp; 接口协议定义了操作系统内部模块之间、以及操作系统与硬件之间的通信方式。设计一个清晰、简洁的接口协议对于内核的模块化、可扩展性和可维护性至关重要。接口协议的设计不仅要关注性能和安全性，还要确保不同组件能够顺畅地协同工作。ours 定义接口协议的目的主要在于支持不同体系架构，其实常见架构内部所提供的内容都是大同小异的，例如页表、TLB、缓存等等。而我们的核心功能可能需要的仅仅只是架构提供内容的一个子集，所以当我们将必要的部分抽象出来，那么这一部分的抽象就成为了架构与核心模块的约定。不妨以页表为例，绝大多数体系架构都支持虚拟地址映射，只是分页的级别、标志位和地址位的分布


## 2.3 内核组件概述
## 2.4 实施方案